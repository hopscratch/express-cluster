// Generated by CoffeeScript 1.8.0
(function() {
  var cluster, http, master, os, worker;

  cluster = require("cluster");

  os = require("os");

  http = require("http");

  master = function(config) {
    var i, respawn, worker, workerCount, workers, _i, _ref, _ref1, online, onlineHandler;
    workerCount = ((_ref = config.count) != null ? _ref : parseInt(process.env.WORKER_COUNT)) || os.cpus().length;
    respawn = typeof config.respawn === "undefined" ? true : Boolean(config.respawn);
    workers = [];

    // Handle custom events
    if (typeof config.onlineListener === 'function') {
      online = 0;
      config.onlineEvent = config.onlineEvent || 'online';

      // Define the function that will determine when all workers are ready
      onlineHandler = function() {
        if (++online == workers.length) {
          config.onlineListener.call(null, workers);
          online = null;
        }
      };

      // If waiting for general online, bind here
      if (config.onlineEvent === 'online') {
        cluster.on('online', onlineHandler);
      }
    }

    if (config.verbose) {
      console.log("Master started on pid " + process.pid + ", forking " + workerCount + " processes");
    }

    for (i = _i = 0, _ref1 = workerCount - 1; 0 <= _ref1 ? _i <= _ref1 : _i >= _ref1; i = 0 <= _ref1 ? ++_i : --_i) {
      worker = cluster.fork();

      // Bind message event if applicable
      if (typeof config.workerListener === 'function' || typeof config.onlineListener === 'function') {
        worker.on("message", function() {
          // Call custom worker listener
          if (typeof config.workerListener === 'function') {
            config.workerListener.apply(null, arguments);
          }

          // Notify our handler that we have another worker online
          if (typeof config.onlineListener === 'function' && arguments.length
            && typeof arguments[0] === 'string' && config.onlineEvent === arguments[0]) {
            onlineHandler();
          }
        });
      }

      workers.push(worker);
    }
    cluster.on("exit", function(worker, code, signal) {
      var idx;
      if (config.verbose) {
        console.log("" + worker.process.pid + " died with code " + code, respawn ? "restarting" : "");
      }
      idx = workers.indexOf(worker);
      if (idx > -1) {
        workers.splice(idx, 1);
      }
      if (respawn) {
        worker = cluster.fork();
        if (typeof config.workerListener === "function") {
          worker.on("message", config.workerListener);
        }
        return workers.push(worker);
      }
    });

    return process.on("SIGQUIT", function() {
      var _j, _len, _results;
      respawn = false;
      if (config.verbose) {
        console.log("QUIT received, will exit once all workers have finished current requests");
      }
      _results = [];
      for (_j = 0, _len = workers.length; _j < _len; _j++) {
        worker = workers[_j];
        _results.push(worker.send("quit"));
      }
      return _results;
    });
  };

  worker = function(fn, worker) {
    var server;
    server = fn(worker);
    if (!server) {
      return;
    }
    if (typeof server.on === "function") {
      server.on("close", function() {
        return process.exit();
      });
    }
    if (typeof server.close === "function") {
      return process.on("message", function(msg) {
        if (msg === "quit") {
          return server.close();
        }
      });
    }
  };

  module.exports = function(fn, config) {
    if (config == null) {
      config = {};
    }
    if (cluster.isMaster) {
      return master(config);
    } else {
      return worker(fn, cluster.worker);
    }
  };

}).call(this);
